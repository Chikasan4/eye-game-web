<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>動体視力トレ V11 (REAL TRAJECTORY)</title>
    <style>
        body {
            margin: 0; overflow: hidden;
            background-color: #202020;
            font-family: sans-serif; color: white; touch-action: none;
        }
        #game-container { display: none; width: 100%; height: 100%; }
        canvas { display: block; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; padding: 20px; box-sizing: border-box;
            display: flex; justify-content: space-between;
        }
        .hud { font-size: 18px; font-weight: bold; text-shadow: 1px 1px 2px black; }
        
        #menu-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #1a1a1a; display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 100;
            overflow-y: auto; 
        }
        h1 { margin: 20px 0; font-size: 24px; text-align: center; color: #00FF7F; }
        
        .btn {
            width: 85%; max-width: 350px; padding: 15px; margin: 8px 0;
            font-size: 18px; font-weight: bold; color: white;
            background-color: #444; border: 2px solid #00FF7F;
            border-radius: 12px; cursor: pointer; text-align: center;
        }
        .btn:active { transform: scale(0.96); background-color: #555; }
        
        .label { color: #aaa; font-size: 14px; margin-top: 15px; margin-bottom: 5px; width: 85%; max-width: 350px; text-align: left;}

        .btn-badminton { background-color: #2E8B57; border-color: white; }
        /* V11新モード用ボタン */
        .btn-real { background-color: #4169E1; border-color: #00BFFF; color: #fff; }
        .btn-measure { background-color: #b22222; border-color: #ff6347; }

        /* ジャッジ結果表示 */
        #feedback-msg {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            font-size: 40px; font-weight: 900; opacity: 0; pointer-events: none;
            transition: opacity 0.2s; text-shadow: 2px 2px 0 #000; z-index: 20; white-space: nowrap;
        }

        #result-screen {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.9); flex-direction: column;
            align-items: center; justify-content: center; z-index: 50;
        }
        #result-msg { font-size: 24px; margin-bottom: 10px; color: #ccc; }
        #result-score { font-size: 40px; font-weight: bold; color: #00FF7F; margin-bottom: 20px; text-align: center;}
        #result-detail { font-size: 18px; color: white; margin-bottom: 30px; text-align: center; line-height: 1.5;}
    </style>
</head>
<body>

    <div id="menu-screen">
        <h1>動体視力トレ V11<br>Real Trajectory</h1>

        <div class="label">■ リアル・シミュレーション (NEW!)</div>
        <div class="btn btn-real" onclick="startGame('real')">⑦ リアル軌道 (斜め・OUT判定)</div>

        <div class="label">■ 脳トレ・測定</div>
        <div class="btn btn-measure" onclick="startGame('judgment')">⑥ ジャッジ＆フェイント</div>
        <div class="btn btn-measure" onclick="startGame('measure')">⑤ 動体視力測定 (サドンデス)</div>

        <div class="label">■ 基礎トレーニング</div>
        <div class="btn" onclick="startGame('random')">①〜③ 基礎モード (ボール)</div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="feedback-msg"></div>
        <div id="ui-layer">
            <div class="hud" id="hud-left">Score: 0</div>
            <div class="hud" id="hud-right">Time: 30</div>
        </div>
    </div>

    <div id="result-screen">
        <div id="result-msg">Finish!</div>
        <div id="result-score">0</div>
        <div id="result-detail">...</div>
        <div class="btn" onclick="backToMenu()">メニューに戻る</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const menuScreen = document.getElementById('menu-screen');
        const gameContainer = document.getElementById('game-container');
        const resultScreen = document.getElementById('result-screen');
        const hudLeft = document.getElementById('hud-left');
        const hudRight = document.getElementById('hud-right');
        const resultScoreEl = document.getElementById('result-score');
        const resultDetailEl = document.getElementById('result-detail');
        const feedbackEl = document.getElementById('feedback-msg');

        let width, height, courtTop, courtBottom, courtLeftTop, courtRightTop, courtLeftBottom, courtRightBottom;
        let gameMode = 'random'; 
        let score = 0;
        let timeLeft = 30;
        let gameActive = false;
        let targets = [];
        let gameLoopId;
        let timerId;
        let frameCount = 0;
        
        let measureSpeed = 1; 
        let missCount = 0;    
        const MAX_MISS = 3;

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            // 台形コートの定義（パースペクティブ）
            courtTop = height * 0.15;
            courtBottom = height * 0.9;
            const topWidth = width * 0.5; // 奥は狭い
            const bottomWidth = width * 0.95; // 手前は広い
            
            courtLeftTop = (width - topWidth) / 2;
            courtRightTop = width - courtLeftTop;
            courtLeftBottom = (width - bottomWidth) / 2;
            courtRightBottom = width - courtLeftBottom;
        }
        window.addEventListener('resize', resize);
        resize();

        function startGame(mode) {
            if(mode === 'random') mode = 'random'; 
            gameMode = mode;
            menuScreen.style.display = 'none';
            resultScreen.style.display = 'none';
            gameContainer.style.display = 'block';
            
            score = 0;
            frameCount = 0;
            targets = [];
            
            if (gameMode === 'real') {
                timeLeft = 60; 
                hudLeft.innerText = "Score: 0";
                hudRight.innerText = "Time: 60";
                spawnShuttle();
                startTimer();
            } else if (gameMode === 'judgment') {
                timeLeft = 45; 
                hudLeft.innerText = "Score: 0";
                hudRight.innerText = "Time: 45";
                spawnShuttle();
                startTimer();
            } else if (gameMode === 'measure') {
                timeLeft = 999; 
                measureSpeed = 2; 
                missCount = 0;
                hudLeft.innerText = `Speed: ${measureSpeed}`;
                hudRight.innerText = `Life: ${MAX_MISS}`;
                spawnShuttle(); 
            } else {
                timeLeft = 30;
                hudLeft.innerText = "Score: 0";
                hudRight.innerText = "Time: 30";
                spawnBall();
                startTimer();
            }

            gameActive = true;
            update();
        }

        function startTimer() {
            clearInterval(timerId);
            timerId = setInterval(() => {
                timeLeft--;
                hudRight.innerText = `Time: ${timeLeft}`;
                if (timeLeft <= 0) endGame();
            }, 1000);
        }

        function backToMenu() {
            resultScreen.style.display = 'none';
            gameContainer.style.display = 'none';
            menuScreen.style.display = 'flex';
        }

        function showFeedback(text, color) {
            feedbackEl.innerText = text;
            feedbackEl.style.color = color;
            feedbackEl.style.opacity = 1;
            setTimeout(() => { feedbackEl.style.opacity = 0; }, 800);
        }

        function endGame() {
            gameActive = false;
            clearInterval(timerId);
            cancelAnimationFrame(gameLoopId);
            
            let msg = "Time Up!";
            let detail = "";
            let finalScoreDisplay = score;

            if (gameMode === 'measure') {
                msg = "測定終了";
                finalScoreDisplay = `MAX: ${measureSpeed}`;
                if (measureSpeed >= 20) detail = "神 (God)";
                else if (measureSpeed >= 15) detail = "上級 (Adv)";
                else detail = "一般 (Normal)";
            } else if (gameMode === 'real') {
                msg = "Match Finish!";
                detail = `Score: ${score}<br>(イン/アウト判定)`;
            } else {
                msg = "Finish!";
                detail = `Hits: ${score}`;
            }

            document.getElementById('result-msg').innerText = msg;
            resultScoreEl.innerText = finalScoreDisplay;
            resultDetailEl.innerHTML = detail;
            resultScreen.style.display = 'flex';
        }

        function spawnBall() {
            const r = 30;
            const x = Math.random() * (width - r * 2) + r;
            const y = Math.random() * (height - r * 2) + r;
            targets.push({
                x: x, y: y, r: r, baseR: r,
                vx: (Math.random() - 0.5) * 10, vy: (Math.random() - 0.5) * 10,
                color: '#00FF7F', type: 'ball'
            });
        }

        function spawnShuttle() {
            const baseSize = 25;
            // 常にコート中央奥から出現（よりリアルに）
            const startX = width / 2; 
            const startY = -30;

            let isOut = false; // アウト球かどうか
            let shotType = 0; // 0:Smash/Clear, 1:Drop/Cut, 2:Hairpin

            // モードによるアウト確率
            if (gameMode === 'real' && Math.random() < 0.35) isOut = true; 
            if (gameMode === 'judgment' && Math.random() < 0.2) isOut = true;

            // 軌道の決定（ターゲット地点）
            // インの場合：コート内のどこか
            // アウトの場合：ラインの外
            let targetX, targetY;
            
            // X方向のターゲット（左右）
            const margin = 30; // ライン際のマージン
            if (isOut && Math.random() < 0.6) {
                // サイドアウト (左右どちらかに大きく外す)
                targetX = (Math.random() > 0.5) ? -50 : width + 50;
            } else {
                // イン or オーバー（左右はコート内）
                targetX = courtLeftBottom + Math.random() * (courtRightBottom - courtLeftBottom);
            }

            // Y方向のターゲット（前後）
            // スマッシュ/クリアは奥、ドロップは手前
            const rand = Math.random();
            if (rand < 0.5) shotType = 0; // 奥
            else if (rand < 0.8) shotType = 1; // 中
            else shotType = 2; // 前（ヘアピン）

            if (shotType === 0) {
                targetY = courtBottom * 0.95; // ベースライン付近
                if (isOut && targetX > 0 && targetX < width) {
                    // サイドはインだが、バックアウトの場合
                    targetY = height + 100; // 奥へ突き抜ける
                }
            } else if (shotType === 1) {
                targetY = (courtTop + courtBottom) / 2; // 中央
            } else {
                targetY = courtTop + (courtBottom - courtTop) * 0.2; // ネット前
            }

            let speedVal = 8;
            if (gameMode === 'measure') speedVal = measureSpeed;
            else if (gameMode === 'real') speedVal = 8.5;

            // X方向の速度成分を計算（ターゲットに向かって飛ぶ）
            // 到達までのフレーム数概算（高さ / Y速度）
            const distanceY = targetY - startY;
            const speedY = speedVal * (height / 800);
            const frames = distanceY / speedY;
            const speedX = (targetX - startX) / frames;

            targets.push({
                x: startX, y: startY,
                vx: speedX, vy: speedY,
                baseR: baseSize, currentR: baseSize,
                type: 'shuttle',
                isOut: isOut,
                shotType: shotType,
                colorState: 'normal' // normal, hit (gold), kill (red)
            });
        }

        function update() {
            if (!gameActive) return;
            
            if (gameMode === 'random') {
                ctx.fillStyle = "#202020"; ctx.fillRect(0,0,width,height);
            } else {
                ctx.fillStyle = "#2E8B57"; // コート緑
                ctx.fillRect(0,0,width,height);
                drawTrapezoidCourt(); // 3D風コート
            }

            frameCount++;
            if (gameMode === 'random' && targets.length === 0) spawnBall();
            else if ((gameMode === 'real' || gameMode === 'judgment') && frameCount % 40 === 0) spawnShuttle();

            for (let i = targets.length - 1; i >= 0; i--) {
                const t = targets[i];

                if (t.type === 'ball') {
                    // ボール処理（省略）
                    t.x += t.vx; t.y += t.vy;
                    if (t.x<0 || t.x>width) t.vx *= -1;
                    if (t.y<0 || t.y>height) t.vy *= -1;
                    ctx.beginPath(); ctx.arc(t.x, t.y, t.r, 0, Math.PI*2);
                    ctx.fillStyle = t.color; ctx.fill();
                } else if (t.type === 'shuttle') {
                    
                    t.x += t.vx;
                    t.y += t.vy;
                    
                    // ■ 遠近感の計算（奥は小さく、手前は大きく）
                    let progress = (t.y - courtTop) / (courtBottom - courtTop);
                    // 0.4倍 〜 1.5倍まで変化
                    t.currentR = t.baseR * (0.4 + Math.max(0, Math.min(1.2, progress)) * 1.1);

                    // ■ 色の変化ロジック（タイミング通知）
                    t.colorState = 'normal';
                    
                    // 1. ネット前（ヘアピン/プッシュ）チャンス -> 赤
                    if (t.shotType === 2 && progress > 0.1 && progress < 0.4) {
                        t.colorState = 'kill';
                    }
                    // 2. スマッシュ/ドライブの打点（手元） -> 金
                    else if (progress > 0.7 && progress < 1.0) {
                        t.colorState = 'hit';
                    }

                    drawRealShuttle(t.x, t.y, t.currentR, t.colorState);

                    // ■ 画面外（見送り）判定
                    if (t.y > height + 50) {
                        if (gameMode === 'real') {
                            if (t.isOut) {
                                score += 10; // ナイスジャッジ！
                                showFeedback("OUT!", "lime");
                                hudLeft.innerText = `Score: ${score}`;
                            } else {
                                // インを見逃した
                                showFeedback("IN...", "#aaa");
                            }
                        } else if (gameMode === 'judgment' && t.isOut) {
                             score += 5; showFeedback("WATCH!", "#00FF7F"); hudLeft.innerText = `Score: ${score}`;
                        } else if (gameMode === 'measure') {
                            missCount++; hudRight.innerText = `Life: ${MAX_MISS - missCount}`;
                            if (missCount >= MAX_MISS) endGame(); else spawnShuttle();
                        }
                        targets.splice(i, 1);
                    }
                }
            }
            gameLoopId = requestAnimationFrame(update);
        }

        function drawTrapezoidCourt() {
            // 床（茶色）
            ctx.fillStyle = "#8B4513";
            ctx.fillRect(0,0,width,height);
            // コート内（緑）- 台形描画
            ctx.fillStyle = "#2E8B57";
            ctx.beginPath();
            ctx.moveTo(courtLeftTop, courtTop);
            ctx.lineTo(courtRightTop, courtTop);
            ctx.lineTo(courtRightBottom, courtBottom);
            ctx.lineTo(courtLeftBottom, courtBottom);
            ctx.closePath();
            ctx.fill();

            // ライン（白）
            ctx.strokeStyle = "white"; ctx.lineWidth = 3;
            ctx.beginPath();
            // 外枠
            ctx.moveTo(courtLeftTop, courtTop); ctx.lineTo(courtRightTop, courtTop);
            ctx.lineTo(courtRightBottom, courtBottom); ctx.lineTo(courtLeftBottom, courtBottom);
            ctx.lineTo(courtLeftTop, courtTop);
            
            // ネットライン
            const netY = courtTop + (courtBottom - courtTop) * 0.3;
            // ネットの幅も台形に合わせて補間
            const netLeft = courtLeftTop + (courtLeftBottom - courtLeftTop) * 0.3;
            const netRight = courtRightTop + (courtRightBottom - courtRightTop) * 0.3;
            ctx.moveTo(netLeft, netY); ctx.lineTo(netRight, netY);
            
            // センターライン
            ctx.moveTo(width/2, netY); ctx.lineTo(width/2, courtBottom);
            
            ctx.stroke();
        }

        function drawRealShuttle(x, y, r, state) {
            ctx.save(); ctx.translate(x, y); ctx.rotate(Math.PI);
            
            // 羽根の色
            let featherColor = "rgba(255,255,255,0.9)";
            if (state === 'kill') featherColor = "rgba(255,50,50,0.9)"; // 赤
            if (state === 'hit') featherColor = "rgba(255,215,0,0.9)"; // 金

            ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0, r*1.8, -Math.PI/6, Math.PI/6);
            ctx.closePath(); ctx.fillStyle = featherColor; ctx.fill();
            
            // コルク
            ctx.beginPath(); ctx.arc(0,0, r*0.6, 0, Math.PI*2);
            ctx.fillStyle = (state === 'kill') ? "#8B0000" : "#DAA520"; 
            ctx.fill();
            ctx.restore();
        }

        function handleInput(e) {
            if (!gameActive) return;
            e.preventDefault();
            let hitSomething = false;

            const touches = e.changedTouches || [e];
            for (let i = 0; i < touches.length; i++) {
                const tx = touches[i].clientX;
                const ty = touches[i].clientY;

                for (let j = targets.length - 1; j >= 0; j--) {
                    const t = targets[j];
                    const radius = (t.type === 'shuttle') ? t.currentR : t.r;
                    const margin = 20;

                    if (Math.hypot(t.x - tx, t.y - ty) < radius + margin) {
                        hitSomething = true;

                        // ■ リアルモードの判定
                        if (gameMode === 'real') {
                            if (t.isOut) {
                                // アウト球を触った！
                                score -= 5; 
                                showFeedback("TOUCH OUT!", "red");
                            } else {
                                // インの球を打った！
                                // 色が変わっているタイミングなら高得点
                                if (t.colorState === 'hit' || t.colorState === 'kill') {
                                    score += 2; showFeedback("NICE TIMING!", "cyan");
                                } else {
                                    score += 1; // 普通
                                }
                            }
                            hudLeft.innerText = `Score: ${score}`;
                            targets.splice(j, 1);
                        }
                        // ■ その他のモード
                        else if (gameMode === 'judgment') {
                            if (t.isOut) { score -= 10; showFeedback("OUT!!", "red"); }
                            else { score++; showFeedback("NICE", "cyan"); }
                            hudLeft.innerText = `Score: ${score}`;
                            targets.splice(j, 1);
                        } else if (gameMode === 'measure') {
                            hudLeft.innerText = `Speed: ${measureSpeed} (Hits:${score})`;
                            targets.splice(j, 1);
                            measureSpeed += 0.5;
                            spawnShuttle();
                        } else {
                            score++;
                            hudLeft.innerText = (gameMode==='random')? `Score: ${score}` : `Hits: ${score}`;
                            targets.splice(j, 1);
                            if(gameMode==='random') { spawnBall(); if(score%5===0) spawnBall(); }
                        }
                        break;
                    }
                }
            }
            if (gameMode === 'measure' && !hitSomething) {
                missCount++;
                hudRight.innerText = `Life: ${MAX_MISS - missCount}`;
                if (missCount >= MAX_MISS) endGame();
            }
        }
        window.addEventListener('mousedown', handleInput);
        window.addEventListener('touchstart', handleInput, {passive: false});
    </script>
</body>
</html>