<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Badminton Vision V57</title>
    <style>
        /* V50„ÅÆ„Éá„Ç∂„Ç§„É≥„Éª„Çπ„Çø„Ç§„É´„ÇíÂÆåÂÖ®Á∂ôÊâø */
        body { margin: 0; overflow: hidden; background-color: #8B4513; font-family: sans-serif; color: white; touch-action: none; user-select: none; -webkit-user-select: none; }
        #game-container { display: none; width: 100%; height: 100%; }
        canvas { display: block; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; padding: 15px; box-sizing: border-box; display: flex; justify-content: space-between; }
        .hud { font-size: 18px; font-weight: bold; text-shadow: 1px 1px 2px black; font-family: monospace; }
        #combo-display { color: #FFD700; font-size: 24px; font-weight:900; text-align: center; width: 100%; position: absolute; top: 90px; opacity: 0; transition: opacity 0.1s; text-shadow: 0 0 10px orange; }
        #diff-display { position: absolute; bottom: 20px; right: 20px; font-size: 14px; color: #aaa; text-align: right; }
        #diff-val { font-size: 20px; font-weight: bold; color: white; }
        #dynamic-rule { position: absolute; top: 10%; left: 50%; transform: translate(-50%, 0); font-size: 28px; font-weight: 900; color: white; pointer-events: none; white-space: nowrap; z-index: 6; text-shadow: 2px 2px 0 #000; background-color: rgba(0,0,0,0.5); padding: 5px 15px; border-radius: 20px; display: none; }
        #action-guide { position: absolute; top: 20%; left: 50%; transform: translate(-50%, 0); font-size: 20px; font-weight: bold; color: rgba(255,255,255,0.7); pointer-events: none; white-space: pre-line; z-index: 5; text-align: center; line-height: 1.4; text-shadow: 1px 1px 2px black; }
        #menu-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.92); display: flex; flex-direction: column; align-items: center; justify-content: flex-start; z-index: 100; overflow-y: auto; padding-top: 20px; padding-bottom: 40px; }
        h1 { margin: 10px 0; font-size: 22px; text-align: center; color: #00FF7F; border-bottom: 2px solid #00FF7F; padding-bottom: 5px; }
        .section-title { color: #ddd; font-size: 13px; margin-top: 15px; margin-bottom: 5px; width: 90%; max-width: 350px; text-align: left; border-left: 3px solid #00FF7F; padding-left: 8px; }
        .btn { width: 90%; max-width: 350px; padding: 14px; margin: 6px 0; font-size: 16px; font-weight: bold; color: white; background-color: #333; border: 1px solid #555; border-radius: 6px; cursor: pointer; text-align: center; box-shadow: 0 4px 6px rgba(0,0,0,0.5); }
        .btn:active { transform: scale(0.98); background-color: #444; }
        .btn-vision { background-color: #2F4F4F; border-color: #00FA9A; color: #00FA9A; }
        .btn-measure { background-color: #8B0000; border-color: #FF6347; color: white; }
        #feedback-msg { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); font-size: 40px; font-weight: 900; opacity: 0; transition: opacity 0.1s; text-shadow: 2px 2px 0 #000; z-index: 20; white-space: nowrap; }
        #result-screen, #report-screen { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.95); flex-direction: column; align-items: center; justify-content: center; z-index: 150; }
        #result-main { font-size: 50px; font-weight: 900; color: #00FF7F; margin-bottom: 15px; text-align: center; white-space: pre-line; }
        table { border-collapse: collapse; width: 95%; max-width: 400px; color: white; margin-bottom: 20px; font-size: 14px; }
        th, td { border: 1px solid #444; padding: 8px; text-align: center; }
        th { background-color: #222; color: #00FF7F; }
        .rank-ss { color: #FF00FF; font-weight: 900; text-shadow: 0 0 5px #FF00FF; }
        .rank-s { color: #FFD700; font-weight: 900; }
        #reflex-signal { display: none; position: absolute; top: 50%; left: 50%; width: 200px; height: 200px; border-radius: 50%; transform: translate(-50%, -50%); background-color: #333; border: 4px solid #555; z-index: 10; align-items: center; justify-content: center; font-size: 32px; font-weight: 900; color: white; }
    </style>
</head>
<body>
    <div id="menu-screen">
        <h1>Badminton Vision V57<br><span style="font-size:12px; color:#aaa;">FULL RECOVERY & JUDGMENT</span></h1>
        <div class="btn btn-report" onclick="showReport()">üìä Á∑èÂêà„É¨„Éù„Éº„Éà</div>
        <div class="section-title">„ÄêA„ÄëÂü∫Á§é„ÉªÁúºÁêÉ„Éà„É¨</div>
        <div class="btn btn-vision" onclick="startGame('saccade')">‚ë† Ë∑≥Ë∫çÊÄß (ÂæåÂçä: 1ÂÄãÂà§Êñ≠)</div>
        <div class="btn btn-vision" onclick="startGame('pursuit')">‚ë° ËøΩÂæìÊÄß (TRACE)</div>
        <div class="btn btn-vision" onclick="startGame('depth')">‚ë¢ Ê∑±Ë¶ñÂäõ (RANDOM)</div>
        <div class="section-title">„ÄêB„ÄëÊ∏¨ÂÆö</div>
        <div class="btn btn-measure" onclick="startGame('reflex')">‚ë£ ÂèçÂ∞ÑÁ•ûÁµå (AGE TEST)</div>
        <div class="section-title">„ÄêC„ÄëÂÆüÊà¶ (Âà§Êñ≠Êâì„Å°ÂàÜ„Åë)</div>
        <div class="btn" style="background-color:#191970; border-color:#4169E1;" onclick="startGame('defense')">‚ë§ ÂÆà„Çä (TAP)</div>
        <div class="btn" style="background-color:#8B4500; border-color:#FFA500;" onclick="startGame('offense')">‚ë• Êîª„ÇÅ (Ëµ§‚Üì / Èùí‚Üî)</div>
        <div class="btn" style="background-color:#4B0082; border-color:#9370DB;" onclick="startGame('rally')">‚ë¶ Á∑èÂêà (Mix)</div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="feedback-msg"></div>
        <div id="dynamic-rule">TARGET: üü©</div>
        <div id="action-guide"></div>
        <div id="reflex-signal">WAIT</div>
        <div id="combo-display">0 COMBO</div>
        <div id="diff-display">SPEED: <span id="diff-val">LV.1</span></div>
        <div id="ui-layer">
            <div class="hud" id="hud-left">Score: 0</div>
            <div class="hud" id="hud-right">Time: 30</div>
        </div>
    </div>

    <div id="result-screen">
        <div id="result-title" style="color:#aaa">RESULT</div>
        <div id="result-main">0</div>
        <div id="result-sub" style="margin-bottom:20px">CLASS: -</div>
        <button class="btn" onclick="backToMenu()">„É°„Éã„É•„Éº„Å´Êàª„Çã</button>
    </div>

    <div id="report-screen">
        <h2 style="color:#00FF7F;">TOTAL REPORT</h2>
        <table id="report-table"></table>
        <div class="btn" onclick="closeReport()">Èñâ„Åò„Çã</div>
    </div>

    <script>
        // V50„ÅÆÈñ¢Êï∞ÂÆöÁæ©„Çí„Åô„Åπ„Å¶Á∂≤ÁæÖ
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const menuScreen = document.getElementById('menu-screen');
        const gameContainer = document.getElementById('game-container');
        const resultScreen = document.getElementById('result-screen');
        const reportScreen = document.getElementById('report-screen');
        const hudLeft = document.getElementById('hud-left');
        const hudRight = document.getElementById('hud-right');
        const feedbackEl = document.getElementById('feedback-msg');
        const actionGuideEl = document.getElementById('action-guide');
        const dynamicRuleEl = document.getElementById('dynamic-rule');
        const comboEl = document.getElementById('combo-display');
        const diffValEl = document.getElementById('diff-val');
        const reflexSignal = document.getElementById('reflex-signal');

        let width, height, gameMode = '', score = 0, combo = 0, timeLeft = 30, gameActive = false;
        let targets = [], effects = [], spawnTimer = 0, animationFrameId, gameTimerId;
        let currentDifficulty = 0.0, saccadeTargetColor = 'green', saccadePhase = 1;
        let lastScores = { saccade: 0, pursuit: 0, depth: 0, reflex: null, defense: 0, offense: 0, rally: 0 };
        let bestScores = JSON.parse(localStorage.getItem('bv_bestScores')) || { saccade: 0, pursuit: 0, depth: 0, reflex: null, defense: 0, offense: 0, rally: 0 };
        let reflexData = [], reflexCount = 0, reflexStartTime = 0, reflexState = 'idle', reflexTimeout;
        let isTouching = false, startX = 0, startY = 0, currentX = 0, currentY = 0;

        function resize() { width = window.innerWidth; height = window.innerHeight; canvas.width = width; canvas.height = height; }
        window.addEventListener('resize', resize); resize();

        function getRankInfo(mode, val) {
            if (val === null || val === 0) return { rank: "C", title: "Beginner" };
            if (mode === 'reflex') {
                if(val < 190) return { rank: "S", title: "Top Athlete" };
                if(val < 240) return { rank: "A", title: "Athlete" };
                return { rank: "B", title: "General" };
            }
            if (val >= 2500) return { rank: "SS", title: "Legend" };
            if (val >= 2000) return { rank: "S", title: "Top Athlete" };
            if (val >= 1500) return { rank: "A", title: "Athlete" };
            if (val >= 800) return { rank: "B", title: "General" };
            return { rank: "C", title: "Beginner" };
        }

        function startGame(mode) {
            gameMode = mode; score = 0; combo = 0; targets = []; effects = []; gameActive = true; spawnTimer = 0;
            menuScreen.style.display = 'none'; gameContainer.style.display = 'block'; resultScreen.style.display = 'none';
            reflexSignal.style.display = 'none'; currentDifficulty = 0.0;
            dynamicRuleEl.style.display = (mode === 'saccade') ? 'block' : 'none';
            
            if (mode === 'reflex') {
                startReflexGame();
            } else {
                timeLeft = (mode === 'rally') ? 60 : 30;
                saccadePhase = 1; saccadeTargetColor = 'green'; updateSaccadeRule();
                hudLeft.innerText = "Score: 0"; hudRight.innerText = `Time: ${timeLeft}`;
                startTimer(); update();
            }
        }

        function startTimer() {
            clearInterval(gameTimerId);
            gameTimerId = setInterval(() => {
                timeLeft--; hudRight.innerText = `Time: ${timeLeft}`;
                if (gameMode === 'saccade' && timeLeft === 20) { saccadePhase = 2; showFeedback("JUDGMENT MODE!", "yellow"); }
                if (timeLeft <= 0) finishGame();
            }, 1000);
        }

        function updateSaccadeRule() {
            dynamicRuleEl.innerText = `TARGET: ${saccadeTargetColor === 'green' ? 'üü© GREEN' : 'üü• RED'}`;
            dynamicRuleEl.style.color = saccadeTargetColor === 'green' ? "#00FF7F" : "#FF4500";
            dynamicRuleEl.style.borderColor = saccadeTargetColor === 'green' ? "#00FF7F" : "#FF4500";
        }

        function drawCourt() {
            const cx = width * 0.05, cy = height * 0.2, cw = width * 0.9, ch = height * 0.6;
            ctx.fillStyle = "#2E8B57"; ctx.fillRect(cx, cy, cw, ch);
            ctx.strokeStyle = "white"; ctx.lineWidth = 3; ctx.strokeRect(cx, cy, cw, ch);
            ctx.beginPath(); ctx.moveTo(cx, cy+ch/2); ctx.lineTo(cx+cw, cy+ch/2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(cx, cy+ch*0.1); ctx.lineTo(cx+cw, cy+ch*0.1); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(cx, cy+ch*0.9); ctx.lineTo(cx+cw, cy+ch*0.9); ctx.stroke();
        }

        function drawShuttle(x, y, r, color) {
            ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = "rgba(255,255,255,0.5)"; ctx.beginPath(); ctx.moveTo(x,y); 
            ctx.lineTo(x-r*0.7, y-r*1.4); ctx.lineTo(x+r*0.7, y-r*1.4); ctx.fill();
        }

        function spawnTarget() {
            // ‚ë†Ë∑≥Ë∫çÊÄß„ÅÆ„ÅøÂçò‰∏Ä„Çø„Éº„Ç≤„ÉÉ„ÉàÂà∂Èôê
            if (gameMode === 'saccade' && targets.length > 0) return;
            
            const d = currentDifficulty;
            if (gameMode === 'saccade') {
                let life = 75 - (d * 50);
                if (saccadePhase === 2) { 
                    life *= 0.65; saccadeTargetColor = Math.random() < 0.5 ? 'green' : 'red'; updateSaccadeRule();
                }
                let tType = (saccadePhase === 2 && Math.random() < 0.5) ? 'red' : 'green';
                targets.push({ x: Math.random()*(width-70)+35, y: Math.random()*(height*0.65)+height*0.2, r: 35, color: tType==='red'?'#FF4500':'#00FF7F', type: tType, life: life, maxLife: life });
            } else if (gameMode === 'pursuit') {
                targets.push({ x: width/2, y: height/2, r: 35, color: 'cyan', type: 'moving', angle: 0, speed: 0.03 + d*0.05 });
            } else if (gameMode === 'depth') {
                targets.push({ x: Math.random()*(width-100)+50, y: Math.random()*(height-100)+50, r: 5, color: 'yellow', type: 'zoom', growing: true, maxR: 110, zSpeed: 5 + d*8 });
            } else {
                // ‚ë§„Äú‚ë¶ Áâ©ÁêÜÊºîÁÆó„É≠„Ç∏„ÉÉ„ÇØÂæ©ÂÖÉ
                let type = (gameMode === 'defense') ? 'def' : (gameMode === 'offense') ? (Math.random()<0.6?'off_smash':'off_cut') : (Math.random()<0.4?'def':'feint');
                targets.push({ x: Math.random()*width*0.8+width*0.1, y: height*0.1, r: 15, type: type, speed: 12 + d*20, hitY: height*0.75, state: 'white' });
            }
        }

        function update() {
            if (!gameActive) return;
            ctx.fillStyle = "#8B4513"; ctx.fillRect(0,0,width,height);
            if(['defense', 'offense', 'rally'].includes(gameMode)) drawCourt();

            if (targets.length === 0) { 
                spawnTimer--; 
                if (spawnTimer <= 0) { 
                    spawnTarget(); 
                    spawnTimer = (gameMode==='saccade') ? (5 + Math.random()*15) : (15 - currentDifficulty*12);
                } 
            }
            
            for (let i = targets.length - 1; i >= 0; i--) {
                const t = targets[i];
                if (t.life) {
                    t.life--; if (t.life <= 0) { if (gameMode==='saccade' && t.type===saccadeTargetColor) adjustDifficulty(false); targets.splice(i, 1); continue; }
                    ctx.globalAlpha = t.life/t.maxLife;
                }
                if (t.type === 'moving') { t.angle += t.speed; t.x = width/2 + Math.cos(t.angle*1.5)*(width*0.4); t.y = height/2 + Math.sin(t.angle*2.3)*(height*0.25); }
                else if (t.type === 'zoom') { if(t.growing) { t.r+=t.zSpeed; if(t.r>=t.maxR) t.growing=false; } else { t.r-=t.zSpeed; if(t.r<=0) { adjustDifficulty(false); targets.splice(i,1); continue; } } }
                else if (['def', 'off_smash', 'off_cut', 'feint'].includes(t.type)) {
                    t.y += t.speed; if(t.y > height) { adjustDifficulty(false); targets.splice(i,1); continue; }
                    t.state = (t.y > t.hitY - 60 && t.y < t.hitY + 60) ? 'yellow' : 'white';
                    drawShuttle(t.x, t.y, 20 + (t.y/height)*20, t.state==='yellow'?'#FFD700':'white');
                    continue;
                }
                ctx.beginPath(); ctx.arc(t.x, t.y, t.r, 0, Math.PI*2); ctx.fillStyle = t.color; ctx.fill(); ctx.strokeStyle="white"; ctx.stroke(); ctx.globalAlpha = 1;
            }
            updateEffects(); drawEffects();
            animationFrameId = requestAnimationFrame(update);
        }

        function checkHit(tx, ty, action = 'tap') {
            for (let i = targets.length - 1; i >= 0; i--) {
                const t = targets[i];
                if (Math.hypot(t.x - tx, t.y - ty) < 80) {
                    let hit = false, pts = 60;
                    if (gameMode === 'saccade') {
                        if (t.type === saccadeTargetColor) { hit = true; pts = 100 + combo*4; }
                        else { timeLeft = Math.max(0, timeLeft - 4); showFeedback("-4 SEC!", "red"); adjustDifficulty(false); targets.splice(i,1); return; }
                    } else if (t.type === 'zoom' && t.r > t.maxR*0.8) hit = true;
                    else if (t.state === 'yellow') hit = true;

                    if (hit) {
                        score += Math.floor(pts * (1 + currentDifficulty*2.5));
                        hudLeft.innerText = `Score: ${score}`; showFeedback("HIT!", "cyan");
                        spawnEffect(t.x, t.y); adjustDifficulty(true); targets.splice(i,1);
                    }
                }
            }
        }

        function adjustDifficulty(success) {
            if (success) { combo++; currentDifficulty = Math.min(1.0, currentDifficulty + 0.08); }
            else { combo = 0; currentDifficulty = Math.max(0, currentDifficulty - 0.15); }
            let lv = Math.floor(currentDifficulty * 10) + 1; diffValEl.innerText = currentDifficulty >= 1.0 ? "MAX" : `LV.${lv}`;
        }

        function startReflexGame() { reflexCount = 0; reflexData = []; nextReflex(); }
        function nextReflex() {
            reflexCount++; if(reflexCount > 3) { finishReflex(); return; }
            reflexSignal.style.display = 'flex'; reflexSignal.style.backgroundColor = '#8B0000'; reflexSignal.innerText = "WAIT"; reflexState = 'wait';
            setTimeout(() => { if(gameActive) { reflexSignal.style.backgroundColor = '#00FF7F'; reflexSignal.innerText = "TAP!"; reflexStartTime = performance.now(); reflexState = 'go'; } }, 1500 + Math.random()*2500);
        }
        function handleReflex() { if(reflexState === 'go') { let ms = Math.floor(performance.now() - reflexStartTime); reflexData.push(ms); reflexState = 'idle'; showFeedback(`${ms}ms`, "cyan"); setTimeout(nextReflex, 1000); } }

        function finishReflex() { gameActive = false; score = Math.floor(reflexData.reduce((a,b)=>a+b)/3); finishGame(); }
        function finishGame() { gameActive = false; clearInterval(gameTimerId); cancelAnimationFrame(animationFrameId); bestScores[gameMode] = (gameMode==='reflex') ? (bestScores.reflex?Math.min(bestScores.reflex,score):score) : Math.max(bestScores[gameMode]||0, score); localStorage.setItem('bv_bestScores', JSON.stringify(bestScores)); const info = getRankInfo(gameMode, score); document.getElementById('result-main').innerText = score + (gameMode==='reflex'?"ms":""); document.getElementById('result-sub').innerText = `CLASS: ${info.rank} (${info.title})`; resultScreen.style.display = 'flex'; }
        
        function backToMenu() { resultScreen.style.display = 'none'; gameContainer.style.display = 'none'; menuScreen.style.display = 'flex'; }
        function showReport() { menuScreen.style.display = 'none'; reportScreen.style.display = 'flex'; let html = "<tr><th>È†ÖÁõÆ</th><th>Best</th></tr>"; Object.keys(bestScores).forEach(k => { const info = getRankInfo(k, bestScores[k]); html += `<tr><td>${k}</td><td>${bestScores[k]||0} (${info.rank})</td></tr>`; }); document.getElementById('report-table').innerHTML = html; }
        function closeReport() { reportScreen.style.display = 'none'; menuScreen.style.display = 'flex'; }
        function showFeedback(text, color) { feedbackEl.innerText = text; feedbackEl.style.color = color; feedbackEl.style.opacity = 1; setTimeout(()=>feedbackEl.style.opacity=0, 400); }
        function spawnEffect(x,y) { effects.push({x:x, y:y, life:10, r:10}); }
        function updateEffects() { for(let i=effects.length-1; i>=0; i--) { effects[i].life--; effects[i].r+=5; if(effects[i].life<=0) effects.splice(i,1); } }
        function drawEffects() { for(let e of effects) { ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, Math.PI*2); ctx.strokeStyle = `rgba(255,255,255,${e.life/10})`; ctx.stroke(); } }

        canvas.addEventListener('mousedown', (e) => checkHit(e.clientX, e.clientY));
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); checkHit(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
        reflexSignal.addEventListener('mousedown', handleReflex);
    </script>
</body>
</html>