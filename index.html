<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>動体視力トレ V12 (PHYSICS)</title>
    <style>
        body {
            margin: 0; overflow: hidden;
            background-color: #202020;
            font-family: sans-serif; color: white; touch-action: none;
        }
        #game-container { display: none; width: 100%; height: 100%; }
        canvas { display: block; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; padding: 20px; box-sizing: border-box;
            display: flex; justify-content: space-between;
        }
        .hud { font-size: 18px; font-weight: bold; text-shadow: 1px 1px 2px black; }
        
        #menu-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #1a1a1a; display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 100;
            overflow-y: auto; 
        }
        h1 { margin: 20px 0; font-size: 24px; text-align: center; color: #00FF7F; }
        
        .btn {
            width: 85%; max-width: 350px; padding: 15px; margin: 8px 0;
            font-size: 18px; font-weight: bold; color: white;
            background-color: #444; border: 2px solid #00FF7F;
            border-radius: 12px; cursor: pointer; text-align: center;
        }
        .btn:active { transform: scale(0.96); background-color: #555; }
        
        .label { color: #aaa; font-size: 14px; margin-top: 15px; margin-bottom: 5px; width: 85%; max-width: 350px; text-align: left;}

        /* ジャッジ結果表示 */
        #feedback-msg {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            font-size: 40px; font-weight: 900; opacity: 0; pointer-events: none;
            transition: opacity 0.2s; text-shadow: 2px 2px 0 #000; z-index: 20; white-space: nowrap;
        }

        #result-screen {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.9); flex-direction: column;
            align-items: center; justify-content: center; z-index: 50;
        }
        #result-msg { font-size: 24px; margin-bottom: 10px; color: #ccc; }
        #result-score { font-size: 40px; font-weight: bold; color: #00FF7F; margin-bottom: 20px; text-align: center;}
        #result-detail { font-size: 18px; color: white; margin-bottom: 30px; text-align: center; line-height: 1.5;}
    </style>
</head>
<body>

    <div id="menu-screen">
        <h1>動体視力トレ V12<br>Physics & Shadow</h1>

        <div class="label">■ 物理演算ジャッジ (NEW!)</div>
        <div class="btn" style="background-color:#4682B4; border-color:#87CEEB;" onclick="startGame('physics')">⑧ 影を見て判断 (高低差あり)</div>

        <div class="label">■ 従来モード</div>
        <div class="btn" style="background-color:#b22222; border-color:#ff6347;" onclick="startGame('measure')">⑤ 動体視力測定</div>
        <div class="btn" onclick="startGame('random')">①〜③ 基礎モード</div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="feedback-msg"></div>
        <div id="ui-layer">
            <div class="hud" id="hud-left">Score: 0</div>
            <div class="hud" id="hud-right">Time: 30</div>
        </div>
    </div>

    <div id="result-screen">
        <div id="result-msg">Finish!</div>
        <div id="result-score">0</div>
        <div id="result-detail">...</div>
        <div class="btn" onclick="backToMenu()">メニューに戻る</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const menuScreen = document.getElementById('menu-screen');
        const gameContainer = document.getElementById('game-container');
        const resultScreen = document.getElementById('result-screen');
        const hudLeft = document.getElementById('hud-left');
        const hudRight = document.getElementById('hud-right');
        const resultScoreEl = document.getElementById('result-score');
        const resultDetailEl = document.getElementById('result-detail');
        const feedbackEl = document.getElementById('feedback-msg');

        let width, height;
        let courtX, courtY, courtW, courtH; // コート座標
        let gameMode = 'random'; 
        let score = 0;
        let timeLeft = 30;
        let gameActive = false;
        let targets = [];
        let gameLoopId;
        let timerId;
        let frameCount = 0;
        
        let measureSpeed = 1; 
        let missCount = 0;    
        const MAX_MISS = 3;

        // 物理定数
        const GRAVITY = 0.4;  // 重力
        const AIR_RESISTANCE = 0.98; // 空気抵抗

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            
            // 2Dコート定義（中央に配置）
            courtW = width * 0.85;
            courtH = height * 0.7;
            courtX = (width - courtW) / 2;
            courtY = (height - courtH) / 2 + height * 0.05;
        }
        window.addEventListener('resize', resize);
        resize();

        function startGame(mode) {
            gameMode = mode;
            menuScreen.style.display = 'none';
            resultScreen.style.display = 'none';
            gameContainer.style.display = 'block';
            
            score = 0;
            frameCount = 0;
            targets = [];
            
            if (gameMode === 'physics') {
                timeLeft = 60; 
                hudLeft.innerText = "Score: 0";
                hudRight.innerText = "Time: 60";
                spawnShuttlePhysics(); // 初回スポーン
                startTimer();
            } else if (gameMode === 'measure') {
                timeLeft = 999; 
                measureSpeed = 2; 
                missCount = 0;
                hudLeft.innerText = `Speed: ${measureSpeed}`;
                hudRight.innerText = `Life: ${MAX_MISS}`;
                spawnShuttleMeasure(); 
            } else {
                timeLeft = 30;
                hudLeft.innerText = "Score: 0";
                hudRight.innerText = "Time: 30";
                spawnBall();
                startTimer();
            }

            gameActive = true;
            update();
        }

        function startTimer() {
            clearInterval(timerId);
            timerId = setInterval(() => {
                timeLeft--;
                hudRight.innerText = `Time: ${timeLeft}`;
                if (timeLeft <= 0) endGame();
            }, 1000);
        }

        function backToMenu() {
            resultScreen.style.display = 'none';
            gameContainer.style.display = 'none';
            menuScreen.style.display = 'flex';
        }

        function showFeedback(text, color) {
            feedbackEl.innerText = text;
            feedbackEl.style.color = color;
            feedbackEl.style.opacity = 1;
            setTimeout(() => { feedbackEl.style.opacity = 0; }, 800);
        }

        function endGame() {
            gameActive = false;
            clearInterval(timerId);
            cancelAnimationFrame(gameLoopId);
            
            let msg = "Finish!";
            let detail = `Score: ${score}`;

            if (gameMode === 'measure') {
                msg = "測定終了";
                detail = `Max Speed: ${measureSpeed}`;
            } else if (gameMode === 'physics') {
                msg = "Training Finish";
                detail = `Score: ${score}<br>(イン/アウト見極め)`;
            }

            document.getElementById('result-msg').innerText = msg;
            resultScoreEl.innerText = (gameMode==='measure') ? measureSpeed : score;
            resultDetailEl.innerHTML = detail;
            resultScreen.style.display = 'flex';
        }

        // --- 旧ボールスポーン ---
        function spawnBall() {
            const r = 30;
            const x = Math.random() * (width - r * 2) + r;
            const y = Math.random() * (height - r * 2) + r;
            targets.push({
                x: x, y: y, r: r,
                vx: (Math.random() - 0.5) * 10, vy: (Math.random() - 0.5) * 10,
                color: '#00FF7F', type: 'ball'
            });
        }
        
        // --- 測定用（簡易） ---
        function spawnShuttleMeasure() {
             const baseSize = 25;
             const x = Math.random() * (courtW) + courtX;
             targets.push({
                 x: x, y: -50, z: 0,
                 vx: 0, vy: measureSpeed * (height/600) + 2, vz: 0,
                 baseR: baseSize, type: 'shuttle_simple'
             });
        }

        // --- ★ V12 物理演算スポーン ★ ---
        function spawnShuttlePhysics() {
            // 敵コート奥（画面上部）から発射
            const startX = width / 2;
            const startY = courtY - 50; 
            
            // 目標地点（床の上の座標）を決定
            let targetX, targetY;
            
            // 30%の確率でアウト球
            const isOut = Math.random() < 0.3;

            if (isOut) {
                // アウトの場合：ラインの外側を狙う
                if (Math.random() < 0.5) {
                    // サイドアウト
                    targetX = (Math.random() < 0.5) ? courtX - 50 : courtX + courtW + 50;
                    targetY = courtY + courtH * (0.3 + Math.random()*0.6);
                } else {
                    // バックアウト
                    targetX = courtX + Math.random() * courtW;
                    targetY = courtY + courtH + 100;
                }
            } else {
                // インの場合：コート内
                targetX = courtX + Math.random() * courtW;
                targetY = courtY + Math.random() * courtH;
            }

            // ショットの種類（滞空時間と高さが変わる）
            // 0:クリアー(高・遅), 1:スマッシュ(低・速), 2:ドロップ(低・遅)
            const shotType = Math.floor(Math.random() * 3);
            
            let flightTime = 0; // 到達までのフレーム数
            let initialZ = 0;
            let initialVz = 0;

            if (shotType === 0) { // クリアー
                flightTime = 120; // 2秒滞空
                initialVz = 12;   // 高く上がる
            } else if (shotType === 1) { // スマッシュ
                flightTime = 40;  // 速い
                initialVz = 2;    // あまり上がらない
            } else { // ドロップ
                flightTime = 90;
                initialVz = 6;
            }

            // 速度計算 (距離 / 時間)
            const vx = (targetX - startX) / flightTime;
            const vy = (targetY - startY) / flightTime;

            targets.push({
                x: startX, // 現在の影のX
                y: startY, // 現在の影のY
                z: 0,      // 高さ
                vx: vx, vy: vy, vz: initialVz,
                baseR: 25, 
                type: 'shuttle_physics',
                isOut: isOut,
                landingY: targetY // 最終的な落下地点Y（判定用）
            });
        }

        function update() {
            if (!gameActive) return;
            
            // 背景クリア
            ctx.fillStyle = "#202020"; ctx.fillRect(0,0,width,height);

            // コート描画（2D真上視点）
            if (gameMode === 'physics' || gameMode === 'measure') {
                // 床
                ctx.fillStyle = "#2E8B57";
                ctx.fillRect(courtX, courtY, courtW, courtH);
                
                // ライン
                ctx.strokeStyle = "white"; ctx.lineWidth = 3;
                ctx.strokeRect(courtX, courtY, courtW, courtH); // 外枠
                
                const netY = courtY + courtH * 0.3; // ネット位置（仮）
                ctx.beginPath(); ctx.moveTo(courtX, netY); ctx.lineTo(courtX+courtW, netY); ctx.stroke();
                
                // ダブルスサイドラインなど（装飾）
                ctx.lineWidth = 1;
                ctx.strokeRect(courtX + 20, courtY, courtW - 40, courtH);
            }

            frameCount++;
            if (gameMode === 'random' && targets.length === 0) spawnBall();
            else if (gameMode === 'physics' && frameCount % 60 === 0) spawnShuttlePhysics();
            
            for (let i = targets.length - 1; i >= 0; i--) {
                const t = targets[i];

                if (t.type === 'ball') {
                    // 旧ボール処理
                    t.x += t.vx; t.y += t.vy;
                    if (t.x<0 || t.x>width) t.vx *= -1;
                    if (t.y<0 || t.y>height) t.vy *= -1;
                    ctx.beginPath(); ctx.arc(t.x, t.y, t.r, 0, Math.PI*2);
                    ctx.fillStyle = t.color; ctx.fill();

                } else if (t.type === 'shuttle_simple') {
                    // 測定用処理
                    t.y += t.vy;
                    drawShuttleWithShadow(t.x, t.y, 0, t.baseR);
                    if (t.y > height + 50) {
                        missCount++; hudRight.innerText = `Life: ${MAX_MISS - missCount}`;
                        if (missCount >= MAX_MISS) endGame(); else spawnShuttleMeasure();
                        targets.splice(i, 1);
                    }

                } else if (t.type === 'shuttle_physics') {
                    // ★ 物理演算移動 ★
                    t.x += t.vx;
                    t.y += t.vy;
                    
                    t.z += t.vz;    // 高さに速度を足す
                    t.vz -= GRAVITY; // 重力で落ちる
                    
                    // 地面にめり込まない処理
                    if (t.z < 0) t.z = 0;

                    // 描画（影と本体）
                    drawShuttleWithShadow(t.x, t.y, t.z, t.baseR);

                    // 画面外またはバウンド後の処理
                    // zが0以下（着地）して、しばらくしたら判定
                    if (t.z <= 0 && t.y > courtY) {
                         // 地面についた
                         // ここで自動判定してもいいが、ユーザーが見送る時間を考慮して
                         // 画面下へ消えるまで待つか、着地後数フレームで消す
                    }

                    if (t.y > height + 50) {
                        // 画面外に出た（見送った）
                        if (t.isOut) {
                            score += 10; showFeedback("NICE WATCH!", "#00FF7F");
                        } else {
                            // インを見送った＝ミスとは言わないが点にならない
                            showFeedback("IN...", "#aaa");
                        }
                        hudLeft.innerText = `Score: ${score}`;
                        targets.splice(i, 1);
                    }
                }
            }
            gameLoopId = requestAnimationFrame(update);
        }

        // ★ V12 描画のキモ：影と本体の分離 ★
        function drawShuttleWithShadow(x, y, z, r) {
            // 1. 影を描く (常に地面 x, y にある)
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(1, 0.3); // 影は平べったく
            ctx.beginPath();
            ctx.arc(0, 0, r * 0.8, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(0, 0, 0, 0.4)"; // 半透明の黒
            ctx.fill();
            ctx.restore();

            // 2. 本体を描く (高さ z 分だけ Y座標を上にずらす)
            // zが大きいほど、カメラに近づくのでサイズ(scale)も大きくする
            const visualY = y - z; 
            const scale = 1 + (z / 100); // 高いほどデカい
            
            ctx.save();
            ctx.translate(x, visualY);
            ctx.scale(scale, scale); // 距離による拡大
            ctx.rotate(Math.PI); // 下向き

            // シャトル描画
            ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0, r*1.6, -Math.PI/6, Math.PI/6);
            ctx.closePath(); ctx.fillStyle = "rgba(255,255,255,0.95)"; ctx.fill();
            ctx.beginPath(); ctx.arc(0,0, r*0.5, 0, Math.PI*2);
            ctx.fillStyle = "#DAA520"; ctx.fill(); // コルク
            
            ctx.restore();
            
            // 3. (オプション) 影と本体をつなぐ線（高さガイド）
            // これがあると「浮いてる感」が分かりやすい
            if (z > 5) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x, visualY);
                ctx.strokeStyle = "rgba(255,255,255,0.2)";
                ctx.stroke();
            }
        }

        function handleInput(e) {
            if (!gameActive) return;
            e.preventDefault();
            let hitSomething = false;
            const touches = e.changedTouches || [e];

            for (let i = 0; i < touches.length; i++) {
                const tx = touches[i].clientX;
                const ty = touches[i].clientY;

                for (let j = targets.length - 1; j >= 0; j--) {
                    const t = targets[j];
                    if (t.type === 'ball') { /* 省略 */ continue; }
                    
                    // シャトル判定
                    // 「本体（浮いてる方）」をタップしたか判定
                    const visualY = t.y - (t.z || 0);
                    const scale = 1 + ((t.z||0) / 100);
                    const hitR = t.baseR * scale * 1.5; // 判定大きめ

                    if (Math.hypot(t.x - tx, visualY - ty) < hitR) {
                        hitSomething = true;
                        
                        if (gameMode === 'physics') {
                            if (t.isOut) {
                                // アウト球を触った
                                score -= 5; showFeedback("BAD TOUCH!", "red");
                            } else {
                                // イン球を打った
                                score += 1; showFeedback("HIT", "cyan");
                            }
                            hudLeft.innerText = `Score: ${score}`;
                            targets.splice(j, 1);

                        } else if (gameMode === 'measure') {
                            measureSpeed += 0.5;
                            score++; hudLeft.innerText = `Speed: ${measureSpeed}`;
                            targets.splice(j, 1);
                            spawnShuttleMeasure();
                        }
                        break;
                    }
                }
            }
        }
        window.addEventListener('mousedown', handleInput);
        window.addEventListener('touchstart', handleInput, {passive: false});
    </script>
</body>
</html>