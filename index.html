<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>動体視力トレ V18 (REBOOT)</title>
    <style>
        body {
            margin: 0; overflow: hidden;
            background-color: #202020;
            font-family: sans-serif; color: white; touch-action: none;
        }
        #game-container { display: none; width: 100%; height: 100%; }
        canvas { display: block; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; padding: 20px; box-sizing: border-box;
            display: flex; justify-content: space-between;
        }
        .hud { font-size: 18px; font-weight: bold; text-shadow: 1px 1px 2px black; }
        
        #menu-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #1a1a1a; display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 100;
        }
        h1 { margin: 20px 0; font-size: 24px; text-align: center; color: #00FF7F; }
        .btn {
            width: 85%; max-width: 350px; padding: 15px; margin: 8px 0;
            font-size: 18px; font-weight: bold; color: white;
            background-color: #444; border: 2px solid #00FF7F;
            border-radius: 12px; cursor: pointer; text-align: center;
        }
        .btn:active { transform: scale(0.96); background-color: #555; }
        .label { color: #aaa; font-size: 14px; margin-top: 15px; margin-bottom: 5px; width: 85%; max-width: 350px; text-align: left;}

        #feedback-msg {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            font-size: 40px; font-weight: 900; opacity: 0; pointer-events: none;
            transition: opacity 0.1s; text-shadow: 2px 2px 0 #000; z-index: 20; white-space: nowrap;
        }
        #result-screen {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.9); flex-direction: column;
            align-items: center; justify-content: center; z-index: 50;
        }
        #result-msg { font-size: 24px; margin-bottom: 10px; color: #ccc; }
        #result-score { font-size: 40px; font-weight: bold; color: #00FF7F; margin-bottom: 20px; text-align: center;}
    </style>
</head>
<body>

    <div id="menu-screen">
        <h1>動体視力トレ V18<br>System Reboot</h1>
        <div class="label">■ ノック練習</div>
        <div class="btn" style="background-color:#4682B4; border-color:#87CEEB;" onclick="startGame('rally')">⑧ 4点ノック (無限ループ)</div>
        <div class="label">■ 測定</div>
        <div class="btn" style="background-color:#b22222; border-color:#ff6347;" onclick="startGame('measure')">⑤ 動体視力測定</div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="feedback-msg"></div>
        <div id="ui-layer">
            <div class="hud" id="hud-left">Score: 0</div>
            <div class="hud" id="hud-right">Time: 60</div>
        </div>
    </div>

    <div id="result-screen">
        <div id="result-msg">Finish!</div>
        <div id="result-score">0</div>
        <div class="btn" onclick="backToMenu()">メニューに戻る</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const menuScreen = document.getElementById('menu-screen');
        const gameContainer = document.getElementById('game-container');
        const resultScreen = document.getElementById('result-screen');
        const hudLeft = document.getElementById('hud-left');
        const hudRight = document.getElementById('hud-right');
        const resultScoreEl = document.getElementById('result-score');
        const feedbackEl = document.getElementById('feedback-msg');

        let width, height;
        let courtX, courtY, courtW, courtH; 
        let gameMode = 'rally'; 
        let score = 0;
        let timeLeft = 60;
        let gameActive = false;
        let targets = []; // ここには常に最大1個しか入れない
        let effects = [];
        let gameLoopId;
        let timerId;
        let spawnTimer = 0; // 次のスポーンまでのカウントダウン

        // 物理定数
        const GRAVITY = 0.45; 
        
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            courtW = width * 0.92;
            courtH = height * 0.75;
            courtX = (width - courtW) / 2;
            courtY = (height - courtH) / 2 + height * 0.05;
        }
        window.addEventListener('resize', resize);
        resize();

        function startGame(mode) {
            gameMode = mode;
            menuScreen.style.display = 'none';
            resultScreen.style.display = 'none';
            gameContainer.style.display = 'block';
            
            score = 0;
            targets = [];
            effects = [];
            spawnTimer = 10; // すぐ出す

            if (gameMode === 'rally') {
                timeLeft = 60; 
                hudLeft.innerText = "Score: 0";
                hudRight.innerText = "Time: 60";
            } else {
                timeLeft = 999;
                hudLeft.innerText = "Speed: 1";
                hudRight.innerText = "Life: 3";
            }
            
            startTimer();
            gameActive = true;
            update();
        }

        function startTimer() {
            clearInterval(timerId);
            timerId = setInterval(() => {
                if (gameMode === 'rally') {
                    timeLeft--;
                    hudRight.innerText = `Time: ${timeLeft}`;
                    if (timeLeft <= 0) endGame();
                }
            }, 1000);
        }

        function backToMenu() {
            resultScreen.style.display = 'none';
            gameContainer.style.display = 'none';
            menuScreen.style.display = 'flex';
        }

        function showFeedback(text, color) {
            feedbackEl.innerText = text;
            feedbackEl.style.color = color;
            feedbackEl.style.opacity = 1;
            setTimeout(() => { feedbackEl.style.opacity = 0; }, 500);
        }

        function endGame() {
            gameActive = false;
            clearInterval(timerId);
            cancelAnimationFrame(gameLoopId);
            document.getElementById('result-msg').innerText = "Finish!";
            resultScoreEl.innerText = score;
            resultScreen.style.display = 'flex';
        }

        function spawnEffect(x, y) {
            effects.push({ x: x, y: y, life: 10, r: 10 });
        }
        function updateEffects() {
            for (let i = effects.length - 1; i >= 0; i--) {
                const e = effects[i];
                e.life--; e.r += 3; 
                if (e.life <= 0) effects.splice(i, 1);
            }
        }
        function drawEffects() {
            ctx.save();
            for (let e of effects) {
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
                ctx.strokeStyle = `rgba(255, 255, 100, ${e.life / 10})`;
                ctx.lineWidth = 4;
                ctx.stroke();
            }
            ctx.restore();
        }

        // --- コアロジック: 球生成 ---
        function spawnShuttle() {
            const startX = width / 2;
            const startY = courtY - 50; 
            
            // 4点固定 (ランダムなズレなし)
            // 0:左奥, 1:右奥, 2:左前, 3:右前
            const posId = Math.floor(Math.random() * 4);
            
            let tx, ty, type; // type 0:Clear, 1:Smash, 2:Drop

            if (posId === 0) { // 左奥
                tx = courtX + 30; ty = courtY + courtH - 30; type = 0;
            } else if (posId === 1) { // 右奥
                tx = courtX + courtW - 30; ty = courtY + courtH - 30; type = 0;
            } else if (posId === 2) { // 左前
                tx = courtX + 30; ty = courtY + courtH * 0.2; type = 2;
            } else { // 右前
                tx = courtX + courtW - 30; ty = courtY + courtH * 0.2; type = 2;
            }

            // スマッシュを混ぜる(20%) -> サイドラインへ
            if (Math.random() < 0.2) {
                type = 1;
                ty = courtY + courtH * 0.7; // 中盤
                tx = (Math.random() < 0.5) ? courtX + 10 : courtX + courtW - 10;
            }

            // アウト球 (20%)
            let isOut = false;
            if (Math.random() < 0.2) {
                isOut = true;
                if (type === 0) ty += 60; // バックアウト
                else tx += (tx < width/2) ? -60 : 60; // サイドアウト
            }

            // 物理パラメータ
            let time = 0; let vz = 0;
            if (type === 0) { time = 120; vz = 15; } // ハイクリア
            else if (type === 1) { time = 35; vz = 3; } // スマッシュ
            else { time = 90; vz = 10; } // ドロップ

            const vx = (tx - startX) / time;
            const vy = (ty - startY) / time;

            targets.push({
                x: startX, y: startY, z: 0,
                vx: vx, vy: vy, vz: vz,
                baseR: 25, type: type,
                isOut: isOut, landed: false,
                life: 200 // 安全装置：200フレーム経過したら強制消去
            });
        }

        function update() {
            if (!gameActive) return;
            
            ctx.fillStyle = "#202020"; ctx.fillRect(0,0,width,height);

            // コート描画
            ctx.fillStyle = "#2E8B57"; ctx.fillRect(courtX, courtY, courtW, courtH);
            ctx.strokeStyle = "white"; ctx.lineWidth = 3;
            ctx.strokeRect(courtX, courtY, courtW, courtH); 
            const netY = courtY + courtH * 0.3; 
            ctx.beginPath(); ctx.moveTo(courtX, netY); ctx.lineTo(courtX+courtW, netY); ctx.stroke();
            // センター
            ctx.lineWidth=1;
            ctx.beginPath(); ctx.moveTo(courtX+courtW/2, courtY); ctx.lineTo(courtX+courtW/2, courtY+courtH); ctx.stroke();

            // エフェクト
            updateEffects();
            drawEffects();

            // --- ループ管理 (絶対止まらないロジック) ---
            if (targets.length === 0) {
                spawnTimer--;
                if (spawnTimer <= 0) {
                    spawnShuttle();
                    spawnTimer = 999; // 出したら待機状態へ
                }
            }

            // シャトル更新
            for (let i = targets.length - 1; i >= 0; i--) {
                const t = targets[i];

                if (!t.landed) {
                    t.x += t.vx; t.y += t.vy; t.z += t.vz; t.vz -= GRAVITY;
                    
                    // 着地判定
                    if (t.z <= 0) {
                        t.z = 0; t.landed = true;
                        // インの球を落としたら「ミス」表示して即次へ
                        if (t.y > courtY && t.y < courtY+courtH && t.x > courtX && t.x < courtX+courtW) {
                            if (!t.isOut) {
                                showFeedback("MISS...", "#aaa");
                                // ★重要：ミスしても即座に消して次を出す
                                targets.splice(i, 1);
                                spawnTimer = 30; // 0.5秒後に次
                                continue;
                            }
                        }
                    }
                }

                // 描画
                drawShuttle(t.x, t.y, t.z, t.baseR, t.landed);

                // 寿命管理（画面外 or 時間切れ）
                t.life--;
                if (t.y > height + 50 || t.life <= 0) {
                    if (!t.landed && t.isOut) {
                         score += 10; showFeedback("GOOD WATCH!", "#00FF7F"); hudLeft.innerText = `Score: ${score}`;
                    }
                    targets.splice(i, 1);
                    spawnTimer = 20; // すぐ次
                }
            }
            
            gameLoopId = requestAnimationFrame(update);
        }

        function drawShuttle(x, y, z, r, landed) {
            // 影
            ctx.save(); ctx.translate(x, y); ctx.scale(1, 0.3); 
            ctx.beginPath(); ctx.arc(0, 0, r * 0.8, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(0, 0, 0, 0.4)"; ctx.fill(); ctx.restore();

            // 本体
            const visualY = y - z; 
            const scale = 1 + (z / 100); 
            ctx.save(); ctx.translate(x, visualY); ctx.scale(scale, scale); ctx.rotate(Math.PI); 
            
            const alpha = landed ? 0.5 : 0.95;
            ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0, r*1.6, -Math.PI/6, Math.PI/6);
            ctx.closePath(); ctx.fillStyle = `rgba(255,255,255,${alpha})`; ctx.fill();
            ctx.beginPath(); ctx.arc(0,0, r*0.5, 0, Math.PI*2);
            ctx.fillStyle = landed ? "#888" : "#DAA520"; ctx.fill(); 
            ctx.restore();
        }

        function handleInput(e) {
            if (!gameActive) return;
            e.preventDefault();
            const touches = e.changedTouches || [e];

            for (let i = 0; i < touches.length; i++) {
                const tx = touches[i].clientX;
                const ty = touches[i].clientY;

                for (let j = targets.length - 1; j >= 0; j--) {
                    const t = targets[j];
                    if (t.landed) continue; // 着地後は打てない

                    const visualY = t.y - t.z;
                    const scale = 1 + (t.z / 100);
                    const hitR = t.baseR * scale * 1.5; 

                    if (Math.hypot(t.x - tx, visualY - ty) < hitR) {
                        spawnEffect(t.x, visualY); 
                        
                        if (t.isOut) {
                            score -= 5; showFeedback("BAD TOUCH!", "red");
                        } else {
                            score += 1; showFeedback("HIT!", "cyan");
                        }
                        hudLeft.innerText = `Score: ${score}`;
                        
                        // ★ 打ったら即消す -> これで確実に次が出る
                        targets.splice(j, 1);
                        spawnTimer = 20; // 気持ちいい間隔で次
                        break;
                    }
                }
            }
        }
        window.addEventListener('mousedown', handleInput);
        window.addEventListener('touchstart', handleInput, {passive: false});
    </script>
</body>
</html>